# CSAPP 笔记 02：Bomb Lab 环境配置与反汇编实战

## 一、Bomb Lab 环境配置与调试工具

### 1. 现代化调试：VS Code 远程环境配置

利用 VS Code 的图形化界面作为 GDB 的前端，大幅降低阅读汇编和查看寄存器的认知负荷。

#### A. 远程扩展安装

- **连接状态**：确保 Remote-SSH 已连接到 Linux 虚拟机。
- **安装插件**：在扩展商店搜索 **C/C++ (IntelliSense, debugging...)**。
- **关键动作**：点击绿色的 **"Install in SSH: [HostName]"** 按钮，确保调试适配器安装在 Linux 端而非本地。

#### B. 调试配置文件 (`launch.json`)

在 `.vscode` 目录下创建或修改配置文件。

**核心配置要点**：

1. `stopAtEntry`: 防止炸弹直接爆炸。
2. `args`: 自动填入答案文件。
3. `setupCommands`: **关键！** 设置 Intel 格式汇编和加载自动化脚本。

JSON

```
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(gdb) Launch with Disassembly",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/bomb",
            // 优化1: 自动读取答案文件
            "args": ["${workspaceFolder}/test.txt"],
            "stopAtEntry": true, 
            "cwd": "${workspaceFolder}",
            "MIMode": "gdb",
            "miDebuggerPath": "/usr/bin/gdb",
            "setupCommands": [
                // 优化2: 设置 Intel 格式 (mov dst, src)，更符合直觉
                {
                    "description": "Set Intel Flavor",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                },
                // 优化3: 加载自动化断点脚本
                {
                    "description": "Load Script",
                    "text": "source ${workspaceFolder}/debug_script.gdb",
                    "ignoreFailures": false
                }
            ],
            "externalConsole": false,
            "internalConsoleOptions": "openOnSessionStart", 
            "logging": {
                "engineLogging": false 
            }
        }
    ]
}
```

#### C. 启动与视图

1. **启动**：按 `F5` 启动调试，程序将暂停在 `main` 入口。
2. **开启反汇编**：`Ctrl+Shift+P` -> 输入 **"Open Disassembly View"**。
3. **核心面板**：
   - **寄存器 (Registers)**：实时监控 `%rax` (返回值), `%rsp` (栈顶) 等。
   - **调试控制台 (Debug Console)**：用于输入 GDB 指令进行深度探测。

------

### 2. GDB 命令行与静态分析

嵌入式/驱动开发中的“保命技能”，适用于无 GUI 环境 (Headless) 或内核调试。

#### A. 静态反汇编 (Static Disassembly)

在运行程序前，先生成完整的汇编代码文件，用于全局浏览函数结构。

- **指令**：

  Bash

  ```
  objdump -d bomb > bomb.asm
  ```

- **作用**：通读 `bomb.asm`，可以快速定位各个 `phase` 函数的地址，以及查看全局变量（如跳转表）的布局。

#### B. GDB 常用动态调试指令表

| **分类**   | **指令 (简写)** | **参数示例**     | **说明**                    | **实战意义**                       |
| ---------- | --------------- | ---------------- | --------------------------- | ---------------------------------- |
| **断点**   | `b`             | `b phase_1`      | 在函数入口打断点            | 拦截炸弹检查逻辑                   |
|            |                 | `b *0x401020`    | 在特定**内存地址**打断点    | 精确拦截某条指令 (如无符号函数)    |
|            | `i b`           |                  | 查看所有断点                |                                    |
|            | `d`             | `d 1`            | 删除编号为 1 的断点         |                                    |
| **执行**   | `r`             | `r solution.txt` | 开始运行 (可带参数)         |                                    |
|            | `c`             |                  | 继续运行直到下一个断点      |                                    |
|            | **`ni`**        |                  | **下一条指令 (Step Over)**  | 跳过函数调用，**不进入**子函数     |
|            | **`si`**        |                  | **单步指令 (Step Into)**    | **拆弹核心**，追踪**进入**函数内部 |
|            | `kill`          |                  | 终止当前进程                | 炸弹即将爆炸时紧急“剪线”           |
|            | `finish`        |                  | 跳出函数                    | 误入函数后快速返回上一层           |
| **寄存器** | `i r`           |                  | 查看所有寄存器              |                                    |
|            | `p`             | `p $rax`         | 打印寄存器值 (十进制)       |                                    |
|            |                 | `p/x $rax`       | 打印寄存器值 (**十六进制**) |                                    |
|            |                 | `p (char)0x61`   | 打印 Hex 对应的字符         | 快速查 ASCII 码                    |
| **内存**   | **`x`**         | `x/s 0x4020b0`   | 查看地址处的**字符串**      | **必杀技：查看预设的答案明文**     |
|            |                 | `x/d $rsp`       | 查看栈顶的**整数**          | 检查局部变量、返回地址             |
|            |                 | `x/20gx $rsp`    | 以**64位16进制**查看        | 分析栈帧结构 (Stack Frame)         |

------

## 二、寄存器与调用约定 (ABI)

### 1. 寄存器用途全表

| **寄存器**  | **用途**   | **归属 (谁保存)** | **记忆口诀**                          |
| ----------- | ---------- | ----------------- | ------------------------------------- |
| **%rax**    | **返回值** | 调用者            | **答案寄存器** (函数执行完先看它)     |
| **%rdi**    | **参数 1** | 调用者            | **进门第一人** (输入数据在这里)       |
| **%rsi**    | **参数 2** | 调用者            | 第 2 个                               |
| **%rdx**    | **参数 3** | 调用者            | 第 3 个 (Phase 4 边界常在这里)        |
| **%rcx**    | 参数 4     | 调用者            | 第 4 个                               |
| **%r8**     | 参数 5     | 调用者            | 第 5 个                               |
| **%r9**     | 参数 6     | 调用者            | 第 6 个                               |
| **%rbx**    | 通用/基址  | **被调用者**      | **借了要还** (递归中常用于存本层数据) |
| **%rbp**    | 基址/通用  | **被调用者**      | 要保存                                |
| **%r12-15** | 通用       | **被调用者**      | 要保存                                |
| **%rsp**    | **栈指针** |                   | 指向栈顶 (Stack Pointer)              |

### 2. 调用者保存 vs 被调用者保存

- **调用者保存 (Caller-saved)**: `rax, rdi, rsi, rdx...`
  - **特点**: "用完就扔"。函数调用后，这些寄存器的值可能被子函数改得面目全非。
- **被调用者保存 (Callee-saved)**: `rbx, rbp, r12-r15`
  - **特点**: "借东西要还"。子函数如果用了它们，必须先 `push` 保存，返回前 `pop` 恢复。
  - **实战**: 在反汇编开头看到 `push %rbx`，说明这个函数后续会用 `%rbx` 存重要数据（如 Phase 4 的中间结果）。

------

## 三、各 Phase 核心汇编模式总结 (Patterns)

### Phase 3: 跳转表 (Jump Table / Switch)

这是 `switch` 语句的底层实现，用于多分支跳转。

**关键指令**：

代码段

```
jmpq *0x402470(,%rax,8)
```

**解析**：

- **动作**：间接跳转 (Indirect Jump)。
- **计算公式**：`有效跳转地址 = 基地址(0x402470) + 索引(%rax) × 8`
- **原理**：
  - `0x402470`：内存中一张表的起始位置。
  - `%rax`：你的输入值（索引）。
  - `8`：因为 64 位系统中一个地址占 **8 个字节**。
- **实战**：使用 `x/10gx 0x402470` 可以打印出这张表里所有的跳转目标地址。

### Phase 4: 递归函数 (Recursion)

**关键特征**：

- 函数内部出现了 `call <自身函数名>`。
- 大量使用 `%rbx` 保存中间变量。

**调试战术：黑箱模型 (Black Box)**

- **原理**：不要陷入递归的深渊，只关注 $y=f(x)$。
- **操作**：
  1. **Input**: 观察 `call` 之前的 `%rdi`, `%rsi`, `%rdx`。
  2. **Output**: 观察 `call` 返回后的 `%rax`。
- **避坑指南**：
  - **切记**：不要在递归函数**内部**打断点（如 `b func4`），否则每层递归都会停。
  - **正确**：在**调用者** (`phase_4`) 的 `call` 指令处打断点，配合 `ni` 直接拿到结果。

### Phase 5: 循环与查表 (Loop & Lookup)

**关键特征**：

1. **循环**：代码末尾有跳转回开头的指令（如 `jne 0x40...`）。

2. **位截断 (Masking)**：

   代码段

   ```
   and $0xf, %edx
   ```

   - **含义**：取 `%edx` 的低 4 位。
   - **目的**：将任意字符转换为 **0-15** 的数字，作为数组下标。

3. **数组查表**：

   代码段

   ```
   movzbl 0x4024b0(%rdx), %edx  ; 或 mov 0x4024b0(,%rdx,1), ...
   ```

   - **含义**：以 `%rdx` 为下标，去基地址 `0x4024b0` 取出一个字符。

**实战技巧 (ASCII)**：

- `'0'` = `0x30` (`& 0xF` = 0)
- `'a'` = `0x61` (`& 0xF` = 1)

### Phase 6: 链表重组 (Linked List)

**关键特征**：

- 频繁操作某个固定的堆地址（如 `0x6032d0`）。
- 存在大量的**指针解引用**操作（偏移量 `0x8` 通常是 `next` 指针）。

**逻辑三部曲**：

1. **查重**：双重循环确保输入 6 个不同的数字。
2. **重组**：根据输入数字的顺序，重新连接链表节点。
3. **检查**：遍历新链表，验证节点数值是否**有序**（通常是降序）。



没问题！既然你习惯看 **AT&T 格式**（这是 GDB 和 Linux 的默认格式，确实更“原教旨主义”），那我们就必须把刚才的 Intel 格式笔记全部纠正过来。

AT&T 格式最大的区别在于：

1. **源在前，目的在后**：`mov src, dst`。
2. **内存寻址格式**：`offset(base, index, scale)`。
3. **前缀**：寄存器有 `%`，立即数有 `$`。

这是为你**完全翻新**后的笔记，重点修正了 **第四章** 和 **第五章** 的语法，并删除了配置文件中强制 Intel 格式的命令。

------

## 四、通用汇编内存模式 (The Essence of Pointers) [AT&T 修正版]

这是 C 语言指针在 AT&T 汇编中的底层表现。

核心公式：D(Rb, Ri, S)  ->  Mem[Reg[Rb] + Reg[Ri]*S + D]

### 1. 指针解引用 (Dereferencing)

C 语言概念：*ptr (取指针指向的值)

AT&T 特征：(%reg) (带圆括号)

- **模式 A：直接解引用**

  代码段

  ```
  movq (%rbx), %rax
  ```

  - **方向**：从 `(%rbx)` 也就是指针指向的内存，移动到 `%rax`。
  - **C 代码**：`long val = *ptr;`

- **模式 B：多级指针**

  代码段

  ```
  movq (%rbx), %rax   # rax = *ptr
  movq (%rax), %rcx   # rcx = *rax
  ```

  - **C 代码**：`long val = **ptr;`

### 2. 结构体/链表访问 (Struct/List Access)

C 语言概念：node->next 或 struc.member

AT&T 特征：Offset(%reg) (括号前有数字)

这是 **Phase 6** 的核心。

- **模式**：

  代码段

  ```
  movq 0x8(%rbx), %rax
  ```

  - **解读**：
    1. `%rbx` 是结构体基地址（指针）。
    2. `0x8` 是偏移量。
    3. 动作：取地址 `rbx + 8` 处的内容，放入 `%rax`。
  - **Bomb Lab 实战**：
    - `0x0(%rbx)` 或 `(%rbx)`：通常是 **Value**。
    - `0x8(%rbx)`：通常是 **Next Pointer**。
  - **C 代码**：`struct Node *next = current_node->next;`

### 3. 固定地址操作 (Global/Static Variables)

**AT&T 特征**：直接出现立即数地址（通常不带 `$`，或者作为 displacement）。

- **模式 A：读取变量值**

  代码段

  ```
  movl 0x6032d0, %eax
  ```

  - **含义**：读取内存地址 `0x6032d0` 里的值到 `%eax`。
  - **C 代码**：`int val = global_var;`

- **模式 B：获取变量地址 (指针)**

  代码段

  ```
  leaq 0x6032d0, %rax  # 或者 mov $0x6032d0, %rax
  ```

  - **含义**：把 `0x6032d0` 这个数字本身（地址）放入 `%rax`。
  - **C 代码**：`int *p = &global_var;` (Phase 6 链表头指针常这样获取)

------

## 五、反汇编“翻译”对照表 (Cheat Sheet) [AT&T 版]

| **C 语言含义**     | **AT&T 汇编指令 (Src -> Dst)** | **说明**                             |
| ------------------ | ------------------------------ | ------------------------------------ |
| `val = *ptr`       | `movq (%rbx), %rax`            | 指针取值 (64位)                      |
| `val = ptr->next`  | `movq 0x8(%rbx), %rax`         | 访问结构体成员 (偏移8)               |
| `val = arr[i]`     | `movl (%rbx, %rcx, 4), %eax`   | 数组访问 (int数组, 步长4)            |
| `ptr = &ptr->next` | `leaq 0x8(%rbx), %rax`         | **lea** 取有效地址 (不读内存)        |
| `i++`              | `add $0x1, %eax`               | 立即数要加 `$`                       |
| `if (a == b)`      | `cmp %rsi, %rdi`               | 注意比较顺序：实际上是 `%rdi - %rsi` |
| `i = i & 15`       | `and $0xf, %eax`               | 位运算                               |